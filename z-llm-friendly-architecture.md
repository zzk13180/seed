# LLM 友好的架构设计建议

## 使用说明

**致人类开发者：**
本规范用于指导构建 **“种子项目 (Golden Seed)”** 和统一代码风格。
请依据本规范创建高质量的示例代码，作为 AI 的模仿对象（Few-Shot Examples）。
在 Code Review 中，请以此为标准审查人类或 AI 生成的代码。

**注意：**
本文档**不直接**作为 AI 的 System Prompt。
给 AI 的指令请使用精简后的规则文件：`PROMPT.md`（仅包含核心约束和负面清单）。
具体工作流程请参考：`WORKFLOW.md`。

## 目标：

1. 最大化 LLM 生成正确率，最小化上下文解释成本。
   - 低隐式、可预测、数据驱动；正确率 > 速度；代码即文档；
2. 拒绝工程炫技（优先简洁、显式设计而非复杂炫技）；
3. 在“可维护”前提下，为生成式智能设计的工程最优解。

## 原则：

1. 显式优先 (Explicit over Implicit)
*   **拒绝魔法**：所有依赖、数据流和逻辑必须清晰可见，禁止隐式依赖、隐式上下文、自动注入。
*   **明确引用**：必须使用显式的 `import`，禁止隐式自动导入。
   - 虽然优秀的 auto-import 已经是零魔法、纯静态分析的行为，综合权衡后仍禁止: 
      1. auto-import 一旦存在多来源可能性，LLM 更容易“引用到看起来对但来源不对”的符号；显式 import 强制确定来源。
      2. auto-import 会把“引用关系”变成构建期推断，降低重构、迁移、批量替换时的确定性。
      3. auto-import 会让依赖关系隐藏在构建期行为里，增加排障与审查成本。
      4. monorepo/多应用下最容易出现配置不一致（A 能用、B 不能用），导致改动跨目录时更容易引入“本地能跑、CI/别的包失败”的问题。
      5. 减少“必须同时提供一堆配置文件才能理解”的上下文依赖。
*   **语义化 API**：API 命名即语义，减少 LLM 推理成本。
*   **约定极少**：尽量不依赖“大家都懂”的隐式约定和复杂的抽象层，减少 LLM 理解难度。

2. 数据驱动 (Data-Driven)
*   **内容即数据**：优先使用普通对象（JSON Schema）描述复杂结构（如表单、表格配置）。
*   **利用优势**：LLM 极擅长处理 JSON 结构，应充分利用这一特性。
*   **对象优先**：使用配置对象而非复杂的装饰器模式。

3. 行为局部性 (Locality of Behavior)
*   **同位原则**：将样式、逻辑、模板和状态管理尽可能保存在同一文件中。
*   **软性限制**：虽然鼓励单文件，但当文件超过一定阈值（如 500 行）或包含多个独立逻辑块时，应在同目录下进行物理拆分（Co-location），而非逻辑拆分。
*   **减少跳转**：避免将一个简单的功能拆分到多个文件中。LLM 在处理单文件上下文时表现最佳。
*   **内联优先**：对于非复用的逻辑或样式，优先写在组件内部，而不是过早抽象成全局工具或全局样式。
*   **自包含组件**：组件应尽量包含其运行所需的所有信息。
*   **样式策略**：优先使用可在模板中直接阅读含义的样式方案。

4. 规范化架构 (Standardized Architecture)
*   **目录结构**：保持扁平，深度严格控制在 2-3 层以内。明确目录职责。
*   **数据流向**：严格的单向数据流，禁止隐式双向绑定或黑盒状态管理。
*   **错误处理**：失败方式应简单直接（报错），禁止静默失败（Silent Fail）。

5. 测试策略 (Testing Strategy)
*   **纯函数优先**：优先设计纯函数，便于测试和 LLM 理解。纯函数无副作用，输入确定输出确定。
*   **简单测试**：使用轻量级测试框架。
*   **测试设计原则**：
    *   **结构一致**：测试结构必须高度一致，便于 LLM 模仿。
    *   **断言统一**：保持断言风格统一。
    *   **避免过度 Mock**：Mock 会破坏可预测性，应尽量测试真实逻辑。
*   **覆盖关键逻辑**：重点测试业务逻辑，而非 UI 细节。LLM 生成的代码应通过测试验证正确性。

## 冲突仲裁原则

当多个原则发生冲突时，按照以下优先级顺序解决（优先级从高到低）：
纯函数（Pure Functions） > 显式性（Explicitness） > 行为局部性（Locality of Behavior） > 复用性（Reusability） > DRY（Don't Repeat Yourself）

## 最佳实践：混合策略 (Hybrid Approach)

为了让 LLM 更好地遵守上述原则，建议采用 **“黄金种子 (Golden Seed) + 负面清单 (Negative Constraints)”** 的组合方式。

1.  **黄金种子 (Golden Seed)**：
    *   维护一组完美符合规范的“种子代码”（如典型的 UI 组件、纯逻辑函数、测试文件）。
    *   利用 LLM 的模仿能力，让其参考种子代码生成新功能（Few-Shot Prompting）。
    *   **迭代**：如果 LLM 生成了违反原则的代码（如使用了 auto-import），人工修复后将其加入参考集，形成正向反馈。

2.  **负面清单 (Negative Constraints)**：
    *   在 System Prompt 中明确列出“绝对禁止”的行为（如禁止隐式依赖、禁止过度抽象），以堵住 LLM 基于通用训练数据的“本能”行为。
